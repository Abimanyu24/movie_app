import { Platform } from 'react-native';
import * as FileSystem from 'expo-file-system';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

class Service {
    constructor(client) {
        this.client = client;
    }
    static flatten(data, prefix = '') {
        let output = {};
        for (const [key, value] of Object.entries(data)) {
            let finalKey = prefix ? prefix + '[' + key + ']' : key;
            if (Array.isArray(value)) {
                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));
            }
            else {
                output[finalKey] = value;
            }
        }
        return output;
    }
}
Service.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB

class AppwriteException extends Error {
    constructor(message, code = 0, type = '', response = '') {
        super(message);
        this.name = 'AppwriteException';
        this.message = message;
        this.code = code;
        this.type = type;
        this.response = response;
    }
}
class Client {
    constructor() {
        this.config = {
            endpoint: 'https://cloud.appwrite.io/v1',
            endpointRealtime: '',
            project: '',
            jwt: '',
            locale: '',
            session: '',
            devkey: '',
            platform: '',
        };
        this.headers = {
            'x-sdk-name': 'React Native',
            'x-sdk-platform': 'client',
            'x-sdk-language': 'reactnative',
            'x-sdk-version': '0.19.0',
            'X-Appwrite-Response-Format': '1.8.0',
        };
        this.realtime = {
            socket: undefined,
            timeout: undefined,
            heartbeat: undefined,
            url: '',
            channels: new Set(),
            subscriptions: new Map(),
            subscriptionsCounter: 0,
            reconnect: true,
            reconnectAttempts: 0,
            lastMessage: undefined,
            connect: () => {
                clearTimeout(this.realtime.timeout);
                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {
                    this.realtime.createSocket();
                }, 50);
            },
            getTimeout: () => {
                switch (true) {
                    case this.realtime.reconnectAttempts < 5:
                        return 1000;
                    case this.realtime.reconnectAttempts < 15:
                        return 5000;
                    case this.realtime.reconnectAttempts < 100:
                        return 10000;
                    default:
                        return 60000;
                }
            },
            createHeartbeat: () => {
                if (this.realtime.heartbeat) {
                    clearTimeout(this.realtime.heartbeat);
                }
                this.realtime.heartbeat = window === null || window === void 0 ? void 0 : window.setInterval(() => {
                    var _a;
                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({
                        type: 'ping'
                    }));
                }, 20000);
            },
            createSocket: () => {
                var _a, _b, _c;
                if (this.realtime.channels.size < 1) {
                    this.realtime.reconnect = false;
                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();
                    return;
                }
                const channels = new URLSearchParams();
                channels.set('project', this.config.project);
                this.realtime.channels.forEach(channel => {
                    channels.append('channels[]', channel);
                });
                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();
                if (url !== this.realtime.url || // Check if URL is present
                    !this.realtime.socket || // Check if WebSocket has not been created
                    ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)
                ) {
                    if (this.realtime.socket &&
                        ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)
                    ) {
                        this.realtime.reconnect = false;
                        this.realtime.socket.close();
                    }
                    this.realtime.url = url;
                    // @ts-ignore
                    this.realtime.socket = new WebSocket(url, undefined, {
                        headers: {
                            Origin: `appwrite-${Platform.OS}://${this.config.platform}`
                        }
                    });
                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);
                    this.realtime.socket.addEventListener('open', _event => {
                        this.realtime.reconnectAttempts = 0;
                        this.realtime.createHeartbeat();
                    });
                    this.realtime.socket.addEventListener('close', event => {
                        var _a, _b, _c;
                        if (!this.realtime.reconnect ||
                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error
                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008
                            )) {
                            this.realtime.reconnect = true;
                            return;
                        }
                        const timeout = this.realtime.getTimeout();
                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);
                        setTimeout(() => {
                            this.realtime.reconnectAttempts++;
                            this.realtime.createSocket();
                        }, timeout);
                    });
                }
            },
            onMessage: (event) => {
                try {
                    const message = JSON.parse(event.data);
                    this.realtime.lastMessage = message;
                    switch (message.type) {
                        case 'event':
                            let data = message.data;
                            if (data === null || data === void 0 ? void 0 : data.channels) {
                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));
                                if (!isSubscribed)
                                    return;
                                this.realtime.subscriptions.forEach(subscription => {
                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {
                                        setTimeout(() => subscription.callback(data));
                                    }
                                });
                            }
                            break;
                        case 'pong':
                            break; // Handle pong response if needed
                        case 'error':
                            throw message.data;
                        default:
                            break;
                    }
                }
                catch (e) {
                    console.error(e);
                }
            },
            cleanUp: channels => {
                this.realtime.channels.forEach(channel => {
                    if (channels.includes(channel)) {
                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {
                            return subscription.channels.includes(channel);
                        });
                        if (!found) {
                            this.realtime.channels.delete(channel);
                        }
                    }
                });
            }
        };
    }
    /**
     * Set Endpoint
     *
     * Your project endpoint
     *
     * @param {string} endpoint
     *
     * @returns {this}
     */
    setEndpoint(endpoint) {
        if (!endpoint.startsWith('http://') && !endpoint.startsWith('https://')) {
            throw new AppwriteException('Invalid endpoint URL: ' + endpoint);
        }
        this.config.endpoint = endpoint;
        this.config.endpointRealtime = endpoint.replace('https://', 'wss://').replace('http://', 'ws://');
        return this;
    }
    /**
     * Set Realtime Endpoint
     *
     * @param {string} endpointRealtime
     *
     * @returns {this}
     */
    setEndpointRealtime(endpointRealtime) {
        if (!endpointRealtime.startsWith('ws://') && !endpointRealtime.startsWith('wss://')) {
            throw new AppwriteException('Invalid realtime endpoint URL: ' + endpointRealtime);
        }
        this.config.endpointRealtime = endpointRealtime;
        return this;
    }
    /**
     * Set platform
     *
     * Set platform. Will be used as origin for all requests.
     *
     * @param {string} platform
     * @returns {this}
     */
    setPlatform(platform) {
        this.config.platform = platform;
        return this;
    }
    /**
     * Set Project
     *
     * Your project ID
     *
     * @param value string
     *
     * @return {this}
     */
    setProject(value) {
        this.headers['X-Appwrite-Project'] = value;
        this.config.project = value;
        return this;
    }
    /**
     * Set JWT
     *
     * Your secret JSON Web Token
     *
     * @param value string
     *
     * @return {this}
     */
    setJWT(value) {
        this.headers['X-Appwrite-JWT'] = value;
        this.config.jwt = value;
        return this;
    }
    /**
     * Set Locale
     *
     * @param value string
     *
     * @return {this}
     */
    setLocale(value) {
        this.headers['X-Appwrite-Locale'] = value;
        this.config.locale = value;
        return this;
    }
    /**
     * Set Session
     *
     * The user session to authenticate with
     *
     * @param value string
     *
     * @return {this}
     */
    setSession(value) {
        this.headers['X-Appwrite-Session'] = value;
        this.config.session = value;
        return this;
    }
    /**
     * Set DevKey
     *
     * Your secret dev API key
     *
     * @param value string
     *
     * @return {this}
     */
    setDevKey(value) {
        this.headers['X-Appwrite-Dev-Key'] = value;
        this.config.devkey = value;
        return this;
    }
    /**
     * Subscribes to Appwrite events and passes you the payload in realtime.
     *
     * @param {string|string[]} channels
     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.
     *
     * Possible channels are:
     * - account
     * - collections
     * - collections.[ID]
     * - collections.[ID].documents
     * - documents
     * - documents.[ID]
     * - files
     * - files.[ID]
     * - executions
     * - executions.[ID]
     * - functions.[ID]
     * - teams
     * - teams.[ID]
     * - memberships
     * - memberships.[ID]
     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.
     * @returns {() => void} Unsubscribes from events.
     */
    subscribe(channels, callback) {
        let channelArray = typeof channels === 'string' ? [channels] : channels;
        channelArray.forEach(channel => this.realtime.channels.add(channel));
        const counter = this.realtime.subscriptionsCounter++;
        this.realtime.subscriptions.set(counter, {
            channels: channelArray,
            callback
        });
        this.realtime.connect();
        return () => {
            this.realtime.subscriptions.delete(counter);
            this.realtime.cleanUp(channelArray);
            this.realtime.connect();
        };
    }
    call(method_1, url_1) {
        return __awaiter(this, arguments, void 0, function* (method, url, headers = {}, params = {}, responseType = 'json') {
            var _a, _b;
            method = method.toUpperCase();
            headers = Object.assign({}, this.headers, headers);
            headers.Origin = `appwrite-${Platform.OS}://${this.config.platform}`;
            let options = {
                method,
                headers,
            };
            if (headers['X-Appwrite-Dev-Key'] === undefined) {
                options.credentials = 'include';
            }
            if (method === 'GET') {
                for (const [key, value] of Object.entries(Service.flatten(params))) {
                    url.searchParams.append(key, value);
                }
            }
            else {
                switch (headers['content-type']) {
                    case 'application/json':
                        options.body = JSON.stringify(params);
                        break;
                    case 'multipart/form-data':
                        let formData = new FormData();
                        for (const key in params) {
                            if (Array.isArray(params[key])) {
                                params[key].forEach((value) => {
                                    formData.append(key + '[]', value);
                                });
                            }
                            else {
                                formData.append(key, params[key]);
                            }
                        }
                        options.body = formData;
                        delete headers['content-type'];
                        break;
                }
            }
            try {
                let data = null;
                const response = yield fetch(url.toString(), options);
                const warnings = response.headers.get('x-appwrite-warning');
                if (warnings) {
                    warnings.split(';').forEach((warning) => console.warn('Warning: ' + warning));
                }
                if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {
                    data = yield response.json();
                }
                else if (responseType === 'arrayBuffer') {
                    data = yield response.arrayBuffer();
                }
                else {
                    data = {
                        message: yield response.text()
                    };
                }
                if (400 <= response.status) {
                    let responseText = '';
                    if ((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) {
                        responseText = JSON.stringify(data);
                    }
                    else {
                        responseText = data === null || data === void 0 ? void 0 : data.message;
                    }
                    throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, responseText);
                }
                const cookieFallback = response.headers.get('X-Fallback-Cookies');
                if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {
                    window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');
                    window.localStorage.setItem('cookieFallback', cookieFallback);
                }
                return data;
            }
            catch (e) {
                if (e instanceof AppwriteException) {
                    throw e;
                }
                throw new AppwriteException(e.message);
            }
        });
    }
}

class Account extends Service {
    constructor(client) {
        super(client);
    }
    /**
     * Get the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    get() {
        const apiPath = '/account';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                password: rest[0]
            };
        }
        const email = params.email;
        const password = params.password;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/email';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    listIdentities(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                total: rest[0]
            };
        }
        const queries = params.queries;
        const total = params.total;
        const apiPath = '/account/identities';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    deleteIdentity(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                identityId: paramsOrFirst
            };
        }
        const identityId = params.identityId;
        if (typeof identityId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identityId"');
        }
        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    createJWT() {
        const apiPath = '/account/jwts';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                total: rest[0]
            };
        }
        const queries = params.queries;
        const total = params.total;
        const apiPath = '/account/logs';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateMFA(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                mfa: paramsOrFirst
            };
        }
        const mfa = params.mfa;
        if (typeof mfa === 'undefined') {
            throw new AppwriteException('Missing required parameter: "mfa"');
        }
        const apiPath = '/account/mfa';
        const payload = {};
        if (typeof mfa !== 'undefined') {
            payload['mfa'] = mfa;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createMfaAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createMFAAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMfaAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst,
                otp: rest[0]
            };
        }
        const type = params.type;
        const otp = params.otp;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMFAAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst,
                otp: rest[0]
            };
        }
        const type = params.type;
        const otp = params.otp;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteMfaAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteMFAAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createMfaChallenge(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                factor: paramsOrFirst
            };
        }
        const factor = params.factor;
        if (typeof factor === 'undefined') {
            throw new AppwriteException('Missing required parameter: "factor"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof factor !== 'undefined') {
            payload['factor'] = factor;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createMFAChallenge(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                factor: paramsOrFirst
            };
        }
        const factor = params.factor;
        if (typeof factor === 'undefined') {
            throw new AppwriteException('Missing required parameter: "factor"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof factor !== 'undefined') {
            payload['factor'] = factor;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMfaChallenge(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                challengeId: paramsOrFirst,
                otp: rest[0]
            };
        }
        const challengeId = params.challengeId;
        const otp = params.otp;
        if (typeof challengeId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "challengeId"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof challengeId !== 'undefined') {
            payload['challengeId'] = challengeId;
        }
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMFAChallenge(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                challengeId: paramsOrFirst,
                otp: rest[0]
            };
        }
        const challengeId = params.challengeId;
        const otp = params.otp;
        if (typeof challengeId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "challengeId"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof challengeId !== 'undefined') {
            payload['challengeId'] = challengeId;
        }
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * List the factors available on the account to be used as a MFA challange.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.
     */
    listMfaFactors() {
        const apiPath = '/account/mfa/factors';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List the factors available on the account to be used as a MFA challange.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listMFAFactors() {
        const apiPath = '/account/mfa/factors';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.
     */
    getMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    getMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.
     */
    createMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    createMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.
     */
    updateMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    updateMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateName(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst
            };
        }
        const name = params.name;
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/account/name';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updatePassword(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                password: paramsOrFirst,
                oldPassword: rest[0]
            };
        }
        const password = params.password;
        const oldPassword = params.oldPassword;
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/password';
        const payload = {};
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof oldPassword !== 'undefined') {
            payload['oldPassword'] = oldPassword;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updatePhone(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                phone: paramsOrFirst,
                password: rest[0]
            };
        }
        const phone = params.phone;
        const password = params.password;
        if (typeof phone === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phone"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/phone';
        const payload = {};
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Get the preferences as a key-value object for the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    getPrefs() {
        const apiPath = '/account/prefs';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updatePrefs(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'prefs' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                prefs: paramsOrFirst
            };
        }
        const prefs = params.prefs;
        if (typeof prefs === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prefs"');
        }
        const apiPath = '/account/prefs';
        const payload = {};
        if (typeof prefs !== 'undefined') {
            payload['prefs'] = prefs;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createRecovery(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                url: rest[0]
            };
        }
        const email = params.email;
        const url = params.url;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/recovery';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateRecovery(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0],
                password: rest[1]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        const password = params.password;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/recovery';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Get the list of active sessions across different devices for the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listSessions() {
        const apiPath = '/account/sessions';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * Delete all sessions from the user account and remove any sessions cookies from the end client.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    deleteSessions() {
        const apiPath = '/account/sessions';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    createAnonymousSession() {
        const apiPath = '/account/sessions/anonymous';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createEmailPasswordSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                password: rest[0]
            };
        }
        const email = params.email;
        const password = params.password;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/sessions/email';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMagicURLSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/magic-url';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createOAuth2Session(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                provider: paramsOrFirst,
                success: rest[0],
                failure: rest[1],
                scopes: rest[2]
            };
        }
        const provider = params.provider;
        const success = params.success;
        const failure = params.failure;
        const scopes = params.scopes;
        if (typeof provider === 'undefined') {
            throw new AppwriteException('Missing required parameter: "provider"');
        }
        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);
        const payload = {};
        if (typeof success !== 'undefined') {
            payload['success'] = success;
        }
        if (typeof failure !== 'undefined') {
            payload['failure'] = failure;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    updatePhoneSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/token';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    updateStatus() {
        const apiPath = '/account/status';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createPushTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst,
                identifier: rest[0],
                providerId: rest[1]
            };
        }
        const targetId = params.targetId;
        const identifier = params.identifier;
        const providerId = params.providerId;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        if (typeof identifier === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identifier"');
        }
        const apiPath = '/account/targets/push';
        const payload = {};
        if (typeof targetId !== 'undefined') {
            payload['targetId'] = targetId;
        }
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updatePushTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst,
                identifier: rest[0]
            };
        }
        const targetId = params.targetId;
        const identifier = params.identifier;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        if (typeof identifier === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identifier"');
        }
        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);
        const payload = {};
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deletePushTarget(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst
            };
        }
        const targetId = params.targetId;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createEmailToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                phrase: rest[1]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const phrase = params.phrase;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        const apiPath = '/account/tokens/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof phrase !== 'undefined') {
            payload['phrase'] = phrase;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createMagicURLToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                url: rest[1],
                phrase: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const url = params.url;
        const phrase = params.phrase;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        const apiPath = '/account/tokens/magic-url';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof phrase !== 'undefined') {
            payload['phrase'] = phrase;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createOAuth2Token(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                provider: paramsOrFirst,
                success: rest[0],
                failure: rest[1],
                scopes: rest[2]
            };
        }
        const provider = params.provider;
        const success = params.success;
        const failure = params.failure;
        const scopes = params.scopes;
        if (typeof provider === 'undefined') {
            throw new AppwriteException('Missing required parameter: "provider"');
        }
        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);
        const payload = {};
        if (typeof success !== 'undefined') {
            payload['success'] = success;
        }
        if (typeof failure !== 'undefined') {
            payload['failure'] = failure;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    createPhoneToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                phone: rest[0]
            };
        }
        const userId = params.userId;
        const phone = params.phone;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof phone === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phone"');
        }
        const apiPath = '/account/tokens/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createEmailVerification(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createVerification(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateEmailVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    /**
     * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    createPhoneVerification() {
        const apiPath = '/account/verifications/phone';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updatePhoneVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
}

class Avatars extends Service {
    constructor(client) {
        super(client);
    }
    getBrowser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getCreditCard(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getFavicon(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/favicon';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getFlag(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getImage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst,
                width: rest[0],
                height: rest[1]
            };
        }
        const url = params.url;
        const width = params.width;
        const height = params.height;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/image';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getInitials(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                background: rest[2]
            };
        }
        const name = params.name;
        const width = params.width;
        const height = params.height;
        const background = params.background;
        const apiPath = '/avatars/initials';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getQR(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                text: paramsOrFirst,
                size: rest[0],
                margin: rest[1],
                download: rest[2]
            };
        }
        const text = params.text;
        const size = params.size;
        const margin = params.margin;
        const download = params.download;
        if (typeof text === 'undefined') {
            throw new AppwriteException('Missing required parameter: "text"');
        }
        const apiPath = '/avatars/qr';
        const payload = {};
        if (typeof text !== 'undefined') {
            payload['text'] = text;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof margin !== 'undefined') {
            payload['margin'] = margin;
        }
        if (typeof download !== 'undefined') {
            payload['download'] = download;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getScreenshot(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst,
                headers: rest[0],
                viewportWidth: rest[1],
                viewportHeight: rest[2],
                scale: rest[3],
                theme: rest[4],
                userAgent: rest[5],
                fullpage: rest[6],
                locale: rest[7],
                timezone: rest[8],
                latitude: rest[9],
                longitude: rest[10],
                accuracy: rest[11],
                touch: rest[12],
                permissions: rest[13],
                sleep: rest[14],
                width: rest[15],
                height: rest[16],
                quality: rest[17],
                output: rest[18]
            };
        }
        const url = params.url;
        const headers = params.headers;
        const viewportWidth = params.viewportWidth;
        const viewportHeight = params.viewportHeight;
        const scale = params.scale;
        const theme = params.theme;
        const userAgent = params.userAgent;
        const fullpage = params.fullpage;
        const locale = params.locale;
        const timezone = params.timezone;
        const latitude = params.latitude;
        const longitude = params.longitude;
        const accuracy = params.accuracy;
        const touch = params.touch;
        const permissions = params.permissions;
        const sleep = params.sleep;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        const output = params.output;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/screenshots';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof headers !== 'undefined') {
            payload['headers'] = headers;
        }
        if (typeof viewportWidth !== 'undefined') {
            payload['viewportWidth'] = viewportWidth;
        }
        if (typeof viewportHeight !== 'undefined') {
            payload['viewportHeight'] = viewportHeight;
        }
        if (typeof scale !== 'undefined') {
            payload['scale'] = scale;
        }
        if (typeof theme !== 'undefined') {
            payload['theme'] = theme;
        }
        if (typeof userAgent !== 'undefined') {
            payload['userAgent'] = userAgent;
        }
        if (typeof fullpage !== 'undefined') {
            payload['fullpage'] = fullpage;
        }
        if (typeof locale !== 'undefined') {
            payload['locale'] = locale;
        }
        if (typeof timezone !== 'undefined') {
            payload['timezone'] = timezone;
        }
        if (typeof latitude !== 'undefined') {
            payload['latitude'] = latitude;
        }
        if (typeof longitude !== 'undefined') {
            payload['longitude'] = longitude;
        }
        if (typeof accuracy !== 'undefined') {
            payload['accuracy'] = accuracy;
        }
        if (typeof touch !== 'undefined') {
            payload['touch'] = touch;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof sleep !== 'undefined') {
            payload['sleep'] = sleep;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    /**
     * You can use this endpoint to show different browser icons to your users.
     * The code argument receives the browser code as it appears in your user [GET
     * /account/sessions](https://appwrite.io/docs/references/cloud/client-web/account#getSessions)
     * endpoint. Use width, height and quality arguments to change the output
     * settings.
     *
     * When one dimension is specified and the other is 0, the image is scaled
     * with preserved aspect ratio. If both dimensions are 0, the API provides an
     * image at source quality. If dimensions are not specified, the default size
     * of image returned is 100x100px.
     *
     * @param {Browser} code
     * @param {number} width
     * @param {number} height
     * @param {number} quality
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getBrowserURL(code, width, height, quality) {
        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * The credit card endpoint will return you the icon of the credit card
     * provider you need. Use width, height and quality arguments to change the
     * output settings.
     *
     * When one dimension is specified and the other is 0, the image is scaled
     * with preserved aspect ratio. If both dimensions are 0, the API provides an
     * image at source quality. If dimensions are not specified, the default size
     * of image returned is 100x100px.
     *
     *
     * @param {CreditCard} code
     * @param {number} width
     * @param {number} height
     * @param {number} quality
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getCreditCardURL(code, width, height, quality) {
        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote
     * website URL.
     *
     * This endpoint does not follow HTTP redirects.
     *
     * @param {string} url
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getFaviconURL(url) {
        const apiPath = '/avatars/favicon';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * You can use this endpoint to show different country flags icons to your
     * users. The code argument receives the 2 letter country code. Use width,
     * height and quality arguments to change the output settings. Country codes
     * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.
     *
     * When one dimension is specified and the other is 0, the image is scaled
     * with preserved aspect ratio. If both dimensions are 0, the API provides an
     * image at source quality. If dimensions are not specified, the default size
     * of image returned is 100x100px.
     *
     *
     * @param {Flag} code
     * @param {number} width
     * @param {number} height
     * @param {number} quality
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getFlagURL(code, width, height, quality) {
        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Use this endpoint to fetch a remote image URL and crop it to any image size
     * you want. This endpoint is very useful if you need to crop and display
     * remote images in your app or in case you want to make sure a 3rd party
     * image is properly served using a TLS protocol.
     *
     * When one dimension is specified and the other is 0, the image is scaled
     * with preserved aspect ratio. If both dimensions are 0, the API provides an
     * image at source quality. If dimensions are not specified, the default size
     * of image returned is 400x400px.
     *
     * This endpoint does not follow HTTP redirects.
     *
     * @param {string} url
     * @param {number} width
     * @param {number} height
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getImageURL(url, width, height) {
        const apiPath = '/avatars/image';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Use this endpoint to show your user initials avatar icon on your website or
     * app. By default, this route will try to print your logged-in user name or
     * email initials. You can also overwrite the user name if you pass the 'name'
     * parameter. If no name is given and no user is logged, an empty avatar will
     * be returned.
     *
     * You can use the color and background params to change the avatar colors. By
     * default, a random theme will be selected. The random theme will persist for
     * the user's initials when reloading the same theme will always return for
     * the same initials.
     *
     * When one dimension is specified and the other is 0, the image is scaled
     * with preserved aspect ratio. If both dimensions are 0, the API provides an
     * image at source quality. If dimensions are not specified, the default size
     * of image returned is 100x100px.
     *
     *
     * @param {string} name
     * @param {number} width
     * @param {number} height
     * @param {string} background
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getInitialsURL(name, width, height, background) {
        const apiPath = '/avatars/initials';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Converts a given plain text to a QR code image. You can use the query
     * parameters to change the size and style of the resulting image.
     *
     *
     * @param {string} text
     * @param {number} size
     * @param {number} margin
     * @param {boolean} download
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getQRURL(text, size, margin, download) {
        const apiPath = '/avatars/qr';
        const payload = {};
        if (typeof text !== 'undefined') {
            payload['text'] = text;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof margin !== 'undefined') {
            payload['margin'] = margin;
        }
        if (typeof download !== 'undefined') {
            payload['download'] = download;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Use this endpoint to capture a screenshot of any website URL. This endpoint
     * uses a headless browser to render the webpage and capture it as an image.
     *
     * You can configure the browser viewport size, theme, user agent,
     * geolocation, permissions, and more. Capture either just the viewport or the
     * full page scroll.
     *
     * When width and height are specified, the image is resized accordingly. If
     * both dimensions are 0, the API provides an image at original size. If
     * dimensions are not specified, the default viewport size is 1280x720px.
     *
     * @param {string} url
     * @param {object} headers
     * @param {number} viewportWidth
     * @param {number} viewportHeight
     * @param {number} scale
     * @param {Theme} theme
     * @param {string} userAgent
     * @param {boolean} fullpage
     * @param {string} locale
     * @param {Timezone} timezone
     * @param {number} latitude
     * @param {number} longitude
     * @param {number} accuracy
     * @param {boolean} touch
     * @param {string[]} permissions
     * @param {number} sleep
     * @param {number} width
     * @param {number} height
     * @param {number} quality
     * @param {Output} output
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getScreenshotURL(url, headers, viewportWidth, viewportHeight, scale, theme, userAgent, fullpage, locale, timezone, latitude, longitude, accuracy, touch, permissions, sleep, width, height, quality, output) {
        const apiPath = '/avatars/screenshots';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof headers !== 'undefined') {
            payload['headers'] = headers;
        }
        if (typeof viewportWidth !== 'undefined') {
            payload['viewportWidth'] = viewportWidth;
        }
        if (typeof viewportHeight !== 'undefined') {
            payload['viewportHeight'] = viewportHeight;
        }
        if (typeof scale !== 'undefined') {
            payload['scale'] = scale;
        }
        if (typeof theme !== 'undefined') {
            payload['theme'] = theme;
        }
        if (typeof userAgent !== 'undefined') {
            payload['userAgent'] = userAgent;
        }
        if (typeof fullpage !== 'undefined') {
            payload['fullpage'] = fullpage;
        }
        if (typeof locale !== 'undefined') {
            payload['locale'] = locale;
        }
        if (typeof timezone !== 'undefined') {
            payload['timezone'] = timezone;
        }
        if (typeof latitude !== 'undefined') {
            payload['latitude'] = latitude;
        }
        if (typeof longitude !== 'undefined') {
            payload['longitude'] = longitude;
        }
        if (typeof accuracy !== 'undefined') {
            payload['accuracy'] = accuracy;
        }
        if (typeof touch !== 'undefined') {
            payload['touch'] = touch;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof sleep !== 'undefined') {
            payload['sleep'] = sleep;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
}

class Databases extends Service {
    constructor(client) {
        super(client);
    }
    listTransactions(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/databases/transactions';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createTransaction(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ttl: paramsOrFirst
            };
        }
        const ttl = params.ttl;
        const apiPath = '/databases/transactions';
        const payload = {};
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                commit: rest[0],
                rollback: rest[1]
            };
        }
        const transactionId = params.transactionId;
        const commit = params.commit;
        const rollback = params.rollback;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof commit !== 'undefined') {
            payload['commit'] = commit;
        }
        if (typeof rollback !== 'undefined') {
            payload['rollback'] = rollback;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                operations: rest[0]
            };
        }
        const transactionId = params.transactionId;
        const operations = params.operations;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof operations !== 'undefined') {
            payload['operations'] = operations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    listDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1],
                transactionId: rest[2],
                total: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof data === 'undefined') {
            throw new AppwriteException('Missing required parameter: "data"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof documentId !== 'undefined') {
            payload['documentId'] = documentId;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    upsertDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof data === 'undefined') {
            throw new AppwriteException('Missing required parameter: "data"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    decrementDocumentAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                attribute: rest[2],
                value: rest[3],
                min: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const attribute = params.attribute;
        const value = params.value;
        const min = params.min;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof attribute === 'undefined') {
            throw new AppwriteException('Missing required parameter: "attribute"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    incrementDocumentAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                attribute: rest[2],
                value: rest[3],
                max: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const attribute = params.attribute;
        const value = params.value;
        const max = params.max;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof attribute === 'undefined') {
            throw new AppwriteException('Missing required parameter: "attribute"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
}

class Functions extends Service {
    constructor(client) {
        super(client);
    }
    listExecutions(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const functionId = params.functionId;
        const queries = params.queries;
        const total = params.total;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createExecution(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                body: rest[0],
                async: rest[1],
                xpath: rest[2],
                method: rest[3],
                headers: rest[4],
                scheduledAt: rest[5]
            };
        }
        const functionId = params.functionId;
        const body = params.body;
        const async = params.async;
        const xpath = params.xpath;
        const method = params.method;
        const headers = params.headers;
        const scheduledAt = params.scheduledAt;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof body !== 'undefined') {
            payload['body'] = body;
        }
        if (typeof async !== 'undefined') {
            payload['async'] = async;
        }
        if (typeof xpath !== 'undefined') {
            payload['path'] = xpath;
        }
        if (typeof method !== 'undefined') {
            payload['method'] = method;
        }
        if (typeof headers !== 'undefined') {
            payload['headers'] = headers;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getExecution(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                executionId: rest[0]
            };
        }
        const functionId = params.functionId;
        const executionId = params.executionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof executionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "executionId"');
        }
        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
}

class Graphql extends Service {
    constructor(client) {
        super(client);
    }
    query(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                query: paramsOrFirst
            };
        }
        const query = params.query;
        if (typeof query === 'undefined') {
            throw new AppwriteException('Missing required parameter: "query"');
        }
        const apiPath = '/graphql';
        const payload = {};
        if (typeof query !== 'undefined') {
            payload['query'] = query;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'x-sdk-graphql': 'true',
            'content-type': 'application/json',
        }, payload);
    }
    mutation(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                query: paramsOrFirst
            };
        }
        const query = params.query;
        if (typeof query === 'undefined') {
            throw new AppwriteException('Missing required parameter: "query"');
        }
        const apiPath = '/graphql/mutation';
        const payload = {};
        if (typeof query !== 'undefined') {
            payload['query'] = query;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'x-sdk-graphql': 'true',
            'content-type': 'application/json',
        }, payload);
    }
}

class Locale extends Service {
    constructor(client) {
        super(client);
    }
    /**
     * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.
     *
     * ([IP Geolocation by DB-IP](https://db-ip.com))
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    get() {
        const apiPath = '/locale';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listCodes() {
        const apiPath = '/locale/codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all continents. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listContinents() {
        const apiPath = '/locale/continents';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all countries. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listCountries() {
        const apiPath = '/locale/countries';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listCountriesEU() {
        const apiPath = '/locale/countries/eu';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all countries phone codes. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listCountriesPhones() {
        const apiPath = '/locale/countries/phones';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listCurrencies() {
        const apiPath = '/locale/currencies';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    /**
     * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.
     *
     * @throws {AppwriteException}
     * @returns {Promise}
     */
    listLanguages() {
        const apiPath = '/locale/languages';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
}

class Messaging extends Service {
    constructor(client) {
        super(client);
    }
    createSubscriber(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                subscriberId: rest[0],
                targetId: rest[1]
            };
        }
        const topicId = params.topicId;
        const subscriberId = params.subscriberId;
        const targetId = params.targetId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);
        const payload = {};
        if (typeof subscriberId !== 'undefined') {
            payload['subscriberId'] = subscriberId;
        }
        if (typeof targetId !== 'undefined') {
            payload['targetId'] = targetId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteSubscriber(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                subscriberId: rest[0]
            };
        }
        const topicId = params.topicId;
        const subscriberId = params.subscriberId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
}

class Storage extends Service {
    constructor(client) {
        super(client);
    }
    listFiles(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createFile(paramsOrFirst, ...rest) {
        return __awaiter(this, void 0, void 0, function* () {
            let params;
            let onProgress;
            if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
                params = (paramsOrFirst || {});
                onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;
            }
            else {
                params = {
                    bucketId: paramsOrFirst,
                    fileId: rest[0],
                    file: rest[1],
                    permissions: rest[2]
                };
                onProgress = rest[3];
            }
            const bucketId = params.bucketId;
            const fileId = params.fileId;
            const file = params.file;
            const permissions = params.permissions;
            if (typeof bucketId === 'undefined') {
                throw new AppwriteException('Missing required parameter: "bucketId"');
            }
            if (typeof fileId === 'undefined') {
                throw new AppwriteException('Missing required parameter: "fileId"');
            }
            if (typeof file === 'undefined') {
                throw new AppwriteException('Missing required parameter: "file"');
            }
            const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);
            const payload = {};
            if (typeof fileId !== 'undefined') {
                payload['fileId'] = fileId;
            }
            if (typeof file !== 'undefined') {
                payload['file'] = file;
            }
            if (typeof permissions !== 'undefined') {
                payload['permissions'] = permissions;
            }
            const uri = new URL(this.client.config.endpoint + apiPath);
            const size = file.size;
            if (size <= Service.CHUNK_SIZE) {
                return this.client.call('post', uri, {
                    'content-type': 'multipart/form-data',
                }, payload);
            }
            const apiHeaders = {
                'content-type': 'multipart/form-data',
            };
            let offset = 0;
            let response = undefined;
            try {
                response = yield this.client.call('GET', new URL(this.client.config.endpoint + apiPath + '/' + fileId), apiHeaders);
                offset = response.chunksUploaded * Service.CHUNK_SIZE;
            }
            catch (e) {
            }
            let timestamp = new Date().getTime();
            while (offset < size) {
                let end = Math.min(offset + Service.CHUNK_SIZE - 1, size - 1);
                apiHeaders['content-range'] = 'bytes ' + offset + '-' + end + '/' + size;
                if (response && response.$id) {
                    apiHeaders['x-appwrite-id'] = response.$id;
                }
                let chunk = yield FileSystem.readAsStringAsync(file.uri, {
                    encoding: FileSystem.EncodingType.Base64,
                    position: offset,
                    length: Service.CHUNK_SIZE
                });
                var path = `data:${file.type};base64,${chunk}`;
                if (Platform.OS.toLowerCase() === 'android') {
                    path = FileSystem.cacheDirectory + '/tmp_chunk_' + timestamp;
                    yield FileSystem.writeAsStringAsync(path, chunk, { encoding: FileSystem.EncodingType.Base64 });
                }
                payload['file'] = { uri: path, name: file.name, type: file.type };
                response = yield this.client.call('post', uri, apiHeaders, payload);
                if (onProgress) {
                    onProgress({
                        $id: response.$id,
                        progress: (offset / size) * 100,
                        sizeUploaded: offset,
                        chunksTotal: response.chunksTotal,
                        chunksUploaded: response.chunksUploaded
                    });
                }
                offset += Service.CHUNK_SIZE;
            }
            return response;
        });
    }
    getFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                name: rest[1],
                permissions: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const name = params.name;
        const permissions = params.permissions;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getFileDownload(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                token: rest[1]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getFilePreview(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                width: rest[1],
                height: rest[2],
                gravity: rest[3],
                quality: rest[4],
                borderWidth: rest[5],
                borderColor: rest[6],
                borderRadius: rest[7],
                opacity: rest[8],
                rotation: rest[9],
                background: rest[10],
                output: rest[11],
                token: rest[12]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const width = params.width;
        const height = params.height;
        const gravity = params.gravity;
        const quality = params.quality;
        const borderWidth = params.borderWidth;
        const borderColor = params.borderColor;
        const borderRadius = params.borderRadius;
        const opacity = params.opacity;
        const rotation = params.rotation;
        const background = params.background;
        const output = params.output;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof gravity !== 'undefined') {
            payload['gravity'] = gravity;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof borderWidth !== 'undefined') {
            payload['borderWidth'] = borderWidth;
        }
        if (typeof borderColor !== 'undefined') {
            payload['borderColor'] = borderColor;
        }
        if (typeof borderRadius !== 'undefined') {
            payload['borderRadius'] = borderRadius;
        }
        if (typeof opacity !== 'undefined') {
            payload['opacity'] = opacity;
        }
        if (typeof rotation !== 'undefined') {
            payload['rotation'] = rotation;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    getFileView(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                token: rest[1]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return this.client.call('get', uri, {}, payload, 'arrayBuffer');
    }
    /**
     * Get a file content by its unique ID. The endpoint response return with a
     * 'Content-Disposition: attachment' header that tells the browser to start
     * downloading the file to user downloads directory.
     *
     * @param {string} bucketId
     * @param {string} fileId
     * @param {string} token
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getFileDownloadURL(bucketId, fileId, token) {
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Get a file preview image. Currently, this method supports preview for image
     * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,
     * and spreadsheets, will return the file icon image. You can also pass query
     * string arguments for cutting and resizing your preview image. Preview is
     * supported only for image files smaller than 10MB.
     *
     * @param {string} bucketId
     * @param {string} fileId
     * @param {number} width
     * @param {number} height
     * @param {ImageGravity} gravity
     * @param {number} quality
     * @param {number} borderWidth
     * @param {string} borderColor
     * @param {number} borderRadius
     * @param {number} opacity
     * @param {number} rotation
     * @param {string} background
     * @param {ImageFormat} output
     * @param {string} token
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getFilePreviewURL(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output, token) {
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof gravity !== 'undefined') {
            payload['gravity'] = gravity;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof borderWidth !== 'undefined') {
            payload['borderWidth'] = borderWidth;
        }
        if (typeof borderColor !== 'undefined') {
            payload['borderColor'] = borderColor;
        }
        if (typeof borderRadius !== 'undefined') {
            payload['borderRadius'] = borderRadius;
        }
        if (typeof opacity !== 'undefined') {
            payload['opacity'] = opacity;
        }
        if (typeof rotation !== 'undefined') {
            payload['rotation'] = rotation;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
    /**
     * Get a file content by its unique ID. This endpoint is similar to the
     * download method but returns with no  'Content-Disposition: attachment'
     * header.
     *
     * @param {string} bucketId
     * @param {string} fileId
     * @param {string} token
     * @throws {AppwriteException}
     * @returns {URL}
    */
    getFileViewURL(bucketId, fileId, token) {
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri;
    }
}

class TablesDB extends Service {
    constructor(client) {
        super(client);
    }
    listTransactions(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/tablesdb/transactions';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createTransaction(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ttl: paramsOrFirst
            };
        }
        const ttl = params.ttl;
        const apiPath = '/tablesdb/transactions';
        const payload = {};
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                commit: rest[0],
                rollback: rest[1]
            };
        }
        const transactionId = params.transactionId;
        const commit = params.commit;
        const rollback = params.rollback;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof commit !== 'undefined') {
            payload['commit'] = commit;
        }
        if (typeof rollback !== 'undefined') {
            payload['rollback'] = rollback;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                operations: rest[0]
            };
        }
        const transactionId = params.transactionId;
        const operations = params.operations;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof operations !== 'undefined') {
            payload['operations'] = operations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    listRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1],
                transactionId: rest[2],
                total: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof data === 'undefined') {
            throw new AppwriteException('Missing required parameter: "data"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof rowId !== 'undefined') {
            payload['rowId'] = rowId;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    upsertRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    decrementRowColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                column: rest[2],
                value: rest[3],
                min: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const column = params.column;
        const value = params.value;
        const min = params.min;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof column === 'undefined') {
            throw new AppwriteException('Missing required parameter: "column"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    incrementRowColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                column: rest[2],
                value: rest[3],
                max: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const column = params.column;
        const value = params.value;
        const max = params.max;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof column === 'undefined') {
            throw new AppwriteException('Missing required parameter: "column"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
}

class Teams extends Service {
    constructor(client) {
        super(client);
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/teams';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                name: rest[0],
                roles: rest[1]
            };
        }
        const teamId = params.teamId;
        const name = params.name;
        const roles = params.roles;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/teams';
        const payload = {};
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateName(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                name: rest[0]
            };
        }
        const teamId = params.teamId;
        const name = params.name;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    listMemberships(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const teamId = params.teamId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    createMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                roles: rest[0],
                email: rest[1],
                userId: rest[2],
                phone: rest[3],
                url: rest[4],
                name: rest[5]
            };
        }
        const teamId = params.teamId;
        const roles = params.roles;
        const email = params.email;
        const userId = params.userId;
        const phone = params.phone;
        const url = params.url;
        const name = params.name;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof roles === 'undefined') {
            throw new AppwriteException('Missing required parameter: "roles"');
        }
        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('post', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updateMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0],
                roles: rest[1]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        const roles = params.roles;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        if (typeof roles === 'undefined') {
            throw new AppwriteException('Missing required parameter: "roles"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    deleteMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('delete', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    updateMembershipStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0],
                userId: rest[1],
                secret: rest[2]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        const userId = params.userId;
        const secret = params.secret;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('patch', uri, {
            'content-type': 'application/json',
        }, payload);
    }
    getPrefs(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('get', uri, {}, payload);
    }
    updatePrefs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                prefs: rest[0]
            };
        }
        const teamId = params.teamId;
        const prefs = params.prefs;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof prefs === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prefs"');
        }
        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof prefs !== 'undefined') {
            payload['prefs'] = prefs;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        return this.client.call('put', uri, {
            'content-type': 'application/json',
        }, payload);
    }
}

class Query {
    constructor(method, attribute, values) {
        this.method = method;
        this.attribute = attribute;
        if (values !== undefined) {
            if (Array.isArray(values)) {
                this.values = values;
            }
            else {
                this.values = [values];
            }
        }
    }
    toString() {
        return JSON.stringify({
            method: this.method,
            attribute: this.attribute,
            values: this.values,
        });
    }
}
Query.equal = (attribute, value) => new Query("equal", attribute, value).toString();
Query.notEqual = (attribute, value) => new Query("notEqual", attribute, value).toString();
Query.lessThan = (attribute, value) => new Query("lessThan", attribute, value).toString();
Query.lessThanEqual = (attribute, value) => new Query("lessThanEqual", attribute, value).toString();
Query.greaterThan = (attribute, value) => new Query("greaterThan", attribute, value).toString();
Query.greaterThanEqual = (attribute, value) => new Query("greaterThanEqual", attribute, value).toString();
Query.isNull = (attribute) => new Query("isNull", attribute).toString();
Query.isNotNull = (attribute) => new Query("isNotNull", attribute).toString();
Query.between = (attribute, start, end) => new Query("between", attribute, [start, end]).toString();
Query.startsWith = (attribute, value) => new Query("startsWith", attribute, value).toString();
Query.endsWith = (attribute, value) => new Query("endsWith", attribute, value).toString();
Query.select = (attributes) => new Query("select", undefined, attributes).toString();
Query.search = (attribute, value) => new Query("search", attribute, value).toString();
Query.orderDesc = (attribute) => new Query("orderDesc", attribute).toString();
Query.orderAsc = (attribute) => new Query("orderAsc", attribute).toString();
Query.orderRandom = () => new Query("orderRandom").toString();
Query.cursorAfter = (documentId) => new Query("cursorAfter", undefined, documentId).toString();
Query.cursorBefore = (documentId) => new Query("cursorBefore", undefined, documentId).toString();
Query.limit = (limit) => new Query("limit", undefined, limit).toString();
Query.offset = (offset) => new Query("offset", undefined, offset).toString();
/**
 * Filter resources where attribute contains the specified value.
 *
 * @param {string} attribute
 * @param {string | string[]} value
 * @returns {string}
 */
Query.contains = (attribute, value) => new Query("contains", attribute, value).toString();
/**
 * Filter resources where attribute does not contain the specified value.
 *
 * @param {string} attribute
 * @param {string | string[]} value
 * @returns {string}
 */
Query.notContains = (attribute, value) => new Query("notContains", attribute, value).toString();
/**
 * Filter resources by searching attribute for value (inverse of search).
 * A fulltext index on attribute is required for this query to work.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notSearch = (attribute, value) => new Query("notSearch", attribute, value).toString();
/**
 * Filter resources where attribute is not between start and end (exclusive).
 *
 * @param {string} attribute
 * @param {string | number} start
 * @param {string | number} end
 * @returns {string}
 */
Query.notBetween = (attribute, start, end) => new Query("notBetween", attribute, [start, end]).toString();
/**
 * Filter resources where attribute does not start with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notStartsWith = (attribute, value) => new Query("notStartsWith", attribute, value).toString();
/**
 * Filter resources where attribute does not end with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notEndsWith = (attribute, value) => new Query("notEndsWith", attribute, value).toString();
/**
 * Filter resources where document was created before date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.createdBefore = (value) => Query.lessThan("$createdAt", value);
/**
 * Filter resources where document was created after date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.createdAfter = (value) => Query.greaterThan("$createdAt", value);
/**
 * Filter resources where document was created between dates.
 *
 * @param {string} start
 * @param {string} end
 * @returns {string}
 */
Query.createdBetween = (start, end) => Query.between("$createdAt", start, end);
/**
 * Filter resources where document was updated before date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.updatedBefore = (value) => Query.lessThan("$updatedAt", value);
/**
 * Filter resources where document was updated after date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.updatedAfter = (value) => Query.greaterThan("$updatedAt", value);
/**
 * Filter resources where document was updated between dates.
 *
 * @param {string} start
 * @param {string} end
 * @returns {string}
 */
Query.updatedBetween = (start, end) => Query.between("$updatedAt", start, end);
Query.or = (queries) => new Query("or", undefined, queries.map((query) => JSON.parse(query))).toString();
Query.and = (queries) => new Query("and", undefined, queries.map((query) => JSON.parse(query))).toString();
/**
 * Filter resources where attribute is at a specific distance from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceEqual = (attribute, values, distance, meters = true) => new Query("distanceEqual", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is not at a specific distance from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceNotEqual = (attribute, values, distance, meters = true) => new Query("distanceNotEqual", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceGreaterThan = (attribute, values, distance, meters = true) => new Query("distanceGreaterThan", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is at a distance less than the specified value from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceLessThan = (attribute, values, distance, meters = true) => new Query("distanceLessThan", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute intersects with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.intersects = (attribute, values) => new Query("intersects", attribute, [values]).toString();
/**
 * Filter resources where attribute does not intersect with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notIntersects = (attribute, values) => new Query("notIntersects", attribute, [values]).toString();
/**
 * Filter resources where attribute crosses the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.crosses = (attribute, values) => new Query("crosses", attribute, [values]).toString();
/**
 * Filter resources where attribute does not cross the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notCrosses = (attribute, values) => new Query("notCrosses", attribute, [values]).toString();
/**
 * Filter resources where attribute overlaps with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.overlaps = (attribute, values) => new Query("overlaps", attribute, [values]).toString();
/**
 * Filter resources where attribute does not overlap with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notOverlaps = (attribute, values) => new Query("notOverlaps", attribute, [values]).toString();
/**
 * Filter resources where attribute touches the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.touches = (attribute, values) => new Query("touches", attribute, [values]).toString();
/**
 * Filter resources where attribute does not touch the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notTouches = (attribute, values) => new Query("notTouches", attribute, [values]).toString();

class Permission {
}
Permission.read = (role) => {
    return `read("${role}")`;
};
Permission.write = (role) => {
    return `write("${role}")`;
};
Permission.create = (role) => {
    return `create("${role}")`;
};
Permission.update = (role) => {
    return `update("${role}")`;
};
Permission.delete = (role) => {
    return `delete("${role}")`;
};

/**
 * Helper class to generate role strings for `Permission`.
 */
class Role {
    /**
     * Grants access to anyone.
     *
     * This includes authenticated and unauthenticated users.
     *
     * @returns {string}
     */
    static any() {
        return 'any';
    }
    /**
     * Grants access to a specific user by user ID.
     *
     * You can optionally pass verified or unverified for
     * `status` to target specific types of users.
     *
     * @param {string} id
     * @param {string} status
     * @returns {string}
     */
    static user(id, status = '') {
        if (status === '') {
            return `user:${id}`;
        }
        return `user:${id}/${status}`;
    }
    /**
     * Grants access to any authenticated or anonymous user.
     *
     * You can optionally pass verified or unverified for
     * `status` to target specific types of users.
     *
     * @param {string} status
     * @returns {string}
     */
    static users(status = '') {
        if (status === '') {
            return 'users';
        }
        return `users/${status}`;
    }
    /**
     * Grants access to any guest user without a session.
     *
     * Authenticated users don't have access to this role.
     *
     * @returns {string}
     */
    static guests() {
        return 'guests';
    }
    /**
     * Grants access to a team by team ID.
     *
     * You can optionally pass a role for `role` to target
     * team members with the specified role.
     *
     * @param {string} id
     * @param {string} role
     * @returns {string}
     */
    static team(id, role = '') {
        if (role === '') {
            return `team:${id}`;
        }
        return `team:${id}/${role}`;
    }
    /**
     * Grants access to a specific member of a team.
     *
     * When the member is removed from the team, they will
     * no longer have access.
     *
     * @param {string} id
     * @returns {string}
     */
    static member(id) {
        return `member:${id}`;
    }
    /**
     * Grants access to a user with the specified label.
     *
     * @param {string} name
     * @returns  {string}
     */
    static label(name) {
        return `label:${name}`;
    }
}

var _a, _ID_hexTimestamp;
class ID {
    static custom(id) {
        return id;
    }
    static unique(padding = 7) {
        // Generate a unique ID with padding to have a longer ID
        const baseId = __classPrivateFieldGet(_a, _a, "m", _ID_hexTimestamp).call(_a);
        let randomPadding = '';
        for (let i = 0; i < padding; i++) {
            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
            randomPadding += randomHexDigit;
        }
        return baseId + randomPadding;
    }
}
_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {
    const now = new Date();
    const sec = Math.floor(now.getTime() / 1000);
    const msec = now.getMilliseconds();
    // Convert to hexadecimal
    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');
    return hexTimestamp;
};

var Condition;
(function (Condition) {
    Condition["Equal"] = "equal";
    Condition["NotEqual"] = "notEqual";
    Condition["GreaterThan"] = "greaterThan";
    Condition["GreaterThanEqual"] = "greaterThanEqual";
    Condition["LessThan"] = "lessThan";
    Condition["LessThanEqual"] = "lessThanEqual";
    Condition["Contains"] = "contains";
    Condition["IsNull"] = "isNull";
    Condition["IsNotNull"] = "isNotNull";
})(Condition || (Condition = {}));
/**
 * Helper class to generate operator strings for atomic operations.
 */
class Operator {
    /**
     * Constructor for Operator class.
     *
     * @param {string} method
     * @param {OperatorValues} values
     */
    constructor(method, values) {
        this.method = method;
        if (values !== undefined) {
            if (Array.isArray(values)) {
                this.values = values;
            }
            else {
                this.values = [values];
            }
        }
    }
    /**
     * Convert the operator object to a JSON string.
     *
     * @returns {string}
     */
    toString() {
        return JSON.stringify({
            method: this.method,
            values: this.values,
        });
    }
}
/**
 * Increment a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} max
 * @returns {string}
 */
Operator.increment = (value = 1, max) => {
    if (isNaN(value) || !isFinite(value)) {
        throw new Error("Value cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [value];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("increment", values).toString();
};
/**
 * Decrement a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} min
 * @returns {string}
 */
Operator.decrement = (value = 1, min) => {
    if (isNaN(value) || !isFinite(value)) {
        throw new Error("Value cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
        throw new Error("Min cannot be NaN or Infinity");
    }
    const values = [value];
    if (min !== undefined) {
        values.push(min);
    }
    return new Operator("decrement", values).toString();
};
/**
 * Multiply a numeric attribute by a specified factor.
 *
 * @param {number} factor
 * @param {number} max
 * @returns {string}
 */
Operator.multiply = (factor, max) => {
    if (isNaN(factor) || !isFinite(factor)) {
        throw new Error("Factor cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [factor];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("multiply", values).toString();
};
/**
 * Divide a numeric attribute by a specified divisor.
 *
 * @param {number} divisor
 * @param {number} min
 * @returns {string}
 */
Operator.divide = (divisor, min) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
        throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
        throw new Error("Min cannot be NaN or Infinity");
    }
    if (divisor === 0) {
        throw new Error("Divisor cannot be zero");
    }
    const values = [divisor];
    if (min !== undefined) {
        values.push(min);
    }
    return new Operator("divide", values).toString();
};
/**
 * Apply modulo operation on a numeric attribute.
 *
 * @param {number} divisor
 * @returns {string}
 */
Operator.modulo = (divisor) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
        throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (divisor === 0) {
        throw new Error("Divisor cannot be zero");
    }
    return new Operator("modulo", [divisor]).toString();
};
/**
 * Raise a numeric attribute to a specified power.
 *
 * @param {number} exponent
 * @param {number} max
 * @returns {string}
 */
Operator.power = (exponent, max) => {
    if (isNaN(exponent) || !isFinite(exponent)) {
        throw new Error("Exponent cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [exponent];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("power", values).toString();
};
/**
 * Append values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayAppend = (values) => new Operator("arrayAppend", values).toString();
/**
 * Prepend values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayPrepend = (values) => new Operator("arrayPrepend", values).toString();
/**
 * Insert a value at a specific index in an array attribute.
 *
 * @param {number} index
 * @param {any} value
 * @returns {string}
 */
Operator.arrayInsert = (index, value) => new Operator("arrayInsert", [index, value]).toString();
/**
 * Remove a value from an array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
Operator.arrayRemove = (value) => new Operator("arrayRemove", [value]).toString();
/**
 * Remove duplicate values from an array attribute.
 *
 * @returns {string}
 */
Operator.arrayUnique = () => new Operator("arrayUnique", []).toString();
/**
 * Keep only values that exist in both the current array and the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayIntersect = (values) => new Operator("arrayIntersect", values).toString();
/**
 * Remove values from the array that exist in the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayDiff = (values) => new Operator("arrayDiff", values).toString();
/**
 * Filter array values based on a condition.
 *
 * @param {Condition} condition
 * @param {any} value
 * @returns {string}
 */
Operator.arrayFilter = (condition, value) => {
    const values = [condition, value === undefined ? null : value];
    return new Operator("arrayFilter", values).toString();
};
/**
 * Concatenate a value to a string or array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
Operator.stringConcat = (value) => new Operator("stringConcat", [value]).toString();
/**
 * Replace occurrences of a search string with a replacement string.
 *
 * @param {string} search
 * @param {string} replace
 * @returns {string}
 */
Operator.stringReplace = (search, replace) => new Operator("stringReplace", [search, replace]).toString();
/**
 * Toggle a boolean attribute.
 *
 * @returns {string}
 */
Operator.toggle = () => new Operator("toggle", []).toString();
/**
 * Add days to a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
Operator.dateAddDays = (days) => new Operator("dateAddDays", [days]).toString();
/**
 * Subtract days from a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
Operator.dateSubDays = (days) => new Operator("dateSubDays", [days]).toString();
/**
 * Set a date attribute to the current date and time.
 *
 * @returns {string}
 */
Operator.dateSetNow = () => new Operator("dateSetNow", []).toString();

var AuthenticatorType;
(function (AuthenticatorType) {
    AuthenticatorType["Totp"] = "totp";
})(AuthenticatorType || (AuthenticatorType = {}));

var AuthenticationFactor;
(function (AuthenticationFactor) {
    AuthenticationFactor["Email"] = "email";
    AuthenticationFactor["Phone"] = "phone";
    AuthenticationFactor["Totp"] = "totp";
    AuthenticationFactor["Recoverycode"] = "recoverycode";
})(AuthenticationFactor || (AuthenticationFactor = {}));

var OAuthProvider;
(function (OAuthProvider) {
    OAuthProvider["Amazon"] = "amazon";
    OAuthProvider["Apple"] = "apple";
    OAuthProvider["Auth0"] = "auth0";
    OAuthProvider["Authentik"] = "authentik";
    OAuthProvider["Autodesk"] = "autodesk";
    OAuthProvider["Bitbucket"] = "bitbucket";
    OAuthProvider["Bitly"] = "bitly";
    OAuthProvider["Box"] = "box";
    OAuthProvider["Dailymotion"] = "dailymotion";
    OAuthProvider["Discord"] = "discord";
    OAuthProvider["Disqus"] = "disqus";
    OAuthProvider["Dropbox"] = "dropbox";
    OAuthProvider["Etsy"] = "etsy";
    OAuthProvider["Facebook"] = "facebook";
    OAuthProvider["Figma"] = "figma";
    OAuthProvider["Github"] = "github";
    OAuthProvider["Gitlab"] = "gitlab";
    OAuthProvider["Google"] = "google";
    OAuthProvider["Linkedin"] = "linkedin";
    OAuthProvider["Microsoft"] = "microsoft";
    OAuthProvider["Notion"] = "notion";
    OAuthProvider["Oidc"] = "oidc";
    OAuthProvider["Okta"] = "okta";
    OAuthProvider["Paypal"] = "paypal";
    OAuthProvider["PaypalSandbox"] = "paypalSandbox";
    OAuthProvider["Podio"] = "podio";
    OAuthProvider["Salesforce"] = "salesforce";
    OAuthProvider["Slack"] = "slack";
    OAuthProvider["Spotify"] = "spotify";
    OAuthProvider["Stripe"] = "stripe";
    OAuthProvider["Tradeshift"] = "tradeshift";
    OAuthProvider["TradeshiftBox"] = "tradeshiftBox";
    OAuthProvider["Twitch"] = "twitch";
    OAuthProvider["Wordpress"] = "wordpress";
    OAuthProvider["Yahoo"] = "yahoo";
    OAuthProvider["Yammer"] = "yammer";
    OAuthProvider["Yandex"] = "yandex";
    OAuthProvider["Zoho"] = "zoho";
    OAuthProvider["Zoom"] = "zoom";
    OAuthProvider["Mock"] = "mock";
})(OAuthProvider || (OAuthProvider = {}));

var Browser;
(function (Browser) {
    Browser["AvantBrowser"] = "aa";
    Browser["AndroidWebViewBeta"] = "an";
    Browser["GoogleChrome"] = "ch";
    Browser["GoogleChromeIOS"] = "ci";
    Browser["GoogleChromeMobile"] = "cm";
    Browser["Chromium"] = "cr";
    Browser["MozillaFirefox"] = "ff";
    Browser["Safari"] = "sf";
    Browser["MobileSafari"] = "mf";
    Browser["MicrosoftEdge"] = "ps";
    Browser["MicrosoftEdgeIOS"] = "oi";
    Browser["OperaMini"] = "om";
    Browser["Opera"] = "op";
    Browser["OperaNext"] = "on";
})(Browser || (Browser = {}));

var CreditCard;
(function (CreditCard) {
    CreditCard["AmericanExpress"] = "amex";
    CreditCard["Argencard"] = "argencard";
    CreditCard["Cabal"] = "cabal";
    CreditCard["Cencosud"] = "cencosud";
    CreditCard["DinersClub"] = "diners";
    CreditCard["Discover"] = "discover";
    CreditCard["Elo"] = "elo";
    CreditCard["Hipercard"] = "hipercard";
    CreditCard["JCB"] = "jcb";
    CreditCard["Mastercard"] = "mastercard";
    CreditCard["Naranja"] = "naranja";
    CreditCard["TarjetaShopping"] = "targeta-shopping";
    CreditCard["UnionPay"] = "unionpay";
    CreditCard["Visa"] = "visa";
    CreditCard["MIR"] = "mir";
    CreditCard["Maestro"] = "maestro";
    CreditCard["Rupay"] = "rupay";
})(CreditCard || (CreditCard = {}));

var Flag;
(function (Flag) {
    Flag["Afghanistan"] = "af";
    Flag["Angola"] = "ao";
    Flag["Albania"] = "al";
    Flag["Andorra"] = "ad";
    Flag["UnitedArabEmirates"] = "ae";
    Flag["Argentina"] = "ar";
    Flag["Armenia"] = "am";
    Flag["AntiguaAndBarbuda"] = "ag";
    Flag["Australia"] = "au";
    Flag["Austria"] = "at";
    Flag["Azerbaijan"] = "az";
    Flag["Burundi"] = "bi";
    Flag["Belgium"] = "be";
    Flag["Benin"] = "bj";
    Flag["BurkinaFaso"] = "bf";
    Flag["Bangladesh"] = "bd";
    Flag["Bulgaria"] = "bg";
    Flag["Bahrain"] = "bh";
    Flag["Bahamas"] = "bs";
    Flag["BosniaAndHerzegovina"] = "ba";
    Flag["Belarus"] = "by";
    Flag["Belize"] = "bz";
    Flag["Bolivia"] = "bo";
    Flag["Brazil"] = "br";
    Flag["Barbados"] = "bb";
    Flag["BruneiDarussalam"] = "bn";
    Flag["Bhutan"] = "bt";
    Flag["Botswana"] = "bw";
    Flag["CentralAfricanRepublic"] = "cf";
    Flag["Canada"] = "ca";
    Flag["Switzerland"] = "ch";
    Flag["Chile"] = "cl";
    Flag["China"] = "cn";
    Flag["CoteDIvoire"] = "ci";
    Flag["Cameroon"] = "cm";
    Flag["DemocraticRepublicOfTheCongo"] = "cd";
    Flag["RepublicOfTheCongo"] = "cg";
    Flag["Colombia"] = "co";
    Flag["Comoros"] = "km";
    Flag["CapeVerde"] = "cv";
    Flag["CostaRica"] = "cr";
    Flag["Cuba"] = "cu";
    Flag["Cyprus"] = "cy";
    Flag["CzechRepublic"] = "cz";
    Flag["Germany"] = "de";
    Flag["Djibouti"] = "dj";
    Flag["Dominica"] = "dm";
    Flag["Denmark"] = "dk";
    Flag["DominicanRepublic"] = "do";
    Flag["Algeria"] = "dz";
    Flag["Ecuador"] = "ec";
    Flag["Egypt"] = "eg";
    Flag["Eritrea"] = "er";
    Flag["Spain"] = "es";
    Flag["Estonia"] = "ee";
    Flag["Ethiopia"] = "et";
    Flag["Finland"] = "fi";
    Flag["Fiji"] = "fj";
    Flag["France"] = "fr";
    Flag["MicronesiaFederatedStatesOf"] = "fm";
    Flag["Gabon"] = "ga";
    Flag["UnitedKingdom"] = "gb";
    Flag["Georgia"] = "ge";
    Flag["Ghana"] = "gh";
    Flag["Guinea"] = "gn";
    Flag["Gambia"] = "gm";
    Flag["GuineaBissau"] = "gw";
    Flag["EquatorialGuinea"] = "gq";
    Flag["Greece"] = "gr";
    Flag["Grenada"] = "gd";
    Flag["Guatemala"] = "gt";
    Flag["Guyana"] = "gy";
    Flag["Honduras"] = "hn";
    Flag["Croatia"] = "hr";
    Flag["Haiti"] = "ht";
    Flag["Hungary"] = "hu";
    Flag["Indonesia"] = "id";
    Flag["India"] = "in";
    Flag["Ireland"] = "ie";
    Flag["IranIslamicRepublicOf"] = "ir";
    Flag["Iraq"] = "iq";
    Flag["Iceland"] = "is";
    Flag["Israel"] = "il";
    Flag["Italy"] = "it";
    Flag["Jamaica"] = "jm";
    Flag["Jordan"] = "jo";
    Flag["Japan"] = "jp";
    Flag["Kazakhstan"] = "kz";
    Flag["Kenya"] = "ke";
    Flag["Kyrgyzstan"] = "kg";
    Flag["Cambodia"] = "kh";
    Flag["Kiribati"] = "ki";
    Flag["SaintKittsAndNevis"] = "kn";
    Flag["SouthKorea"] = "kr";
    Flag["Kuwait"] = "kw";
    Flag["LaoPeopleSDemocraticRepublic"] = "la";
    Flag["Lebanon"] = "lb";
    Flag["Liberia"] = "lr";
    Flag["Libya"] = "ly";
    Flag["SaintLucia"] = "lc";
    Flag["Liechtenstein"] = "li";
    Flag["SriLanka"] = "lk";
    Flag["Lesotho"] = "ls";
    Flag["Lithuania"] = "lt";
    Flag["Luxembourg"] = "lu";
    Flag["Latvia"] = "lv";
    Flag["Morocco"] = "ma";
    Flag["Monaco"] = "mc";
    Flag["Moldova"] = "md";
    Flag["Madagascar"] = "mg";
    Flag["Maldives"] = "mv";
    Flag["Mexico"] = "mx";
    Flag["MarshallIslands"] = "mh";
    Flag["NorthMacedonia"] = "mk";
    Flag["Mali"] = "ml";
    Flag["Malta"] = "mt";
    Flag["Myanmar"] = "mm";
    Flag["Montenegro"] = "me";
    Flag["Mongolia"] = "mn";
    Flag["Mozambique"] = "mz";
    Flag["Mauritania"] = "mr";
    Flag["Mauritius"] = "mu";
    Flag["Malawi"] = "mw";
    Flag["Malaysia"] = "my";
    Flag["Namibia"] = "na";
    Flag["Niger"] = "ne";
    Flag["Nigeria"] = "ng";
    Flag["Nicaragua"] = "ni";
    Flag["Netherlands"] = "nl";
    Flag["Norway"] = "no";
    Flag["Nepal"] = "np";
    Flag["Nauru"] = "nr";
    Flag["NewZealand"] = "nz";
    Flag["Oman"] = "om";
    Flag["Pakistan"] = "pk";
    Flag["Panama"] = "pa";
    Flag["Peru"] = "pe";
    Flag["Philippines"] = "ph";
    Flag["Palau"] = "pw";
    Flag["PapuaNewGuinea"] = "pg";
    Flag["Poland"] = "pl";
    Flag["FrenchPolynesia"] = "pf";
    Flag["NorthKorea"] = "kp";
    Flag["Portugal"] = "pt";
    Flag["Paraguay"] = "py";
    Flag["Qatar"] = "qa";
    Flag["Romania"] = "ro";
    Flag["Russia"] = "ru";
    Flag["Rwanda"] = "rw";
    Flag["SaudiArabia"] = "sa";
    Flag["Sudan"] = "sd";
    Flag["Senegal"] = "sn";
    Flag["Singapore"] = "sg";
    Flag["SolomonIslands"] = "sb";
    Flag["SierraLeone"] = "sl";
    Flag["ElSalvador"] = "sv";
    Flag["SanMarino"] = "sm";
    Flag["Somalia"] = "so";
    Flag["Serbia"] = "rs";
    Flag["SouthSudan"] = "ss";
    Flag["SaoTomeAndPrincipe"] = "st";
    Flag["Suriname"] = "sr";
    Flag["Slovakia"] = "sk";
    Flag["Slovenia"] = "si";
    Flag["Sweden"] = "se";
    Flag["Eswatini"] = "sz";
    Flag["Seychelles"] = "sc";
    Flag["Syria"] = "sy";
    Flag["Chad"] = "td";
    Flag["Togo"] = "tg";
    Flag["Thailand"] = "th";
    Flag["Tajikistan"] = "tj";
    Flag["Turkmenistan"] = "tm";
    Flag["TimorLeste"] = "tl";
    Flag["Tonga"] = "to";
    Flag["TrinidadAndTobago"] = "tt";
    Flag["Tunisia"] = "tn";
    Flag["Turkey"] = "tr";
    Flag["Tuvalu"] = "tv";
    Flag["Tanzania"] = "tz";
    Flag["Uganda"] = "ug";
    Flag["Ukraine"] = "ua";
    Flag["Uruguay"] = "uy";
    Flag["UnitedStates"] = "us";
    Flag["Uzbekistan"] = "uz";
    Flag["VaticanCity"] = "va";
    Flag["SaintVincentAndTheGrenadines"] = "vc";
    Flag["Venezuela"] = "ve";
    Flag["Vietnam"] = "vn";
    Flag["Vanuatu"] = "vu";
    Flag["Samoa"] = "ws";
    Flag["Yemen"] = "ye";
    Flag["SouthAfrica"] = "za";
    Flag["Zambia"] = "zm";
    Flag["Zimbabwe"] = "zw";
})(Flag || (Flag = {}));

var Theme;
(function (Theme) {
    Theme["Light"] = "light";
    Theme["Dark"] = "dark";
})(Theme || (Theme = {}));

var Timezone;
(function (Timezone) {
    Timezone["AfricaAbidjan"] = "africa/abidjan";
    Timezone["AfricaAccra"] = "africa/accra";
    Timezone["AfricaAddisAbaba"] = "africa/addis_ababa";
    Timezone["AfricaAlgiers"] = "africa/algiers";
    Timezone["AfricaAsmara"] = "africa/asmara";
    Timezone["AfricaBamako"] = "africa/bamako";
    Timezone["AfricaBangui"] = "africa/bangui";
    Timezone["AfricaBanjul"] = "africa/banjul";
    Timezone["AfricaBissau"] = "africa/bissau";
    Timezone["AfricaBlantyre"] = "africa/blantyre";
    Timezone["AfricaBrazzaville"] = "africa/brazzaville";
    Timezone["AfricaBujumbura"] = "africa/bujumbura";
    Timezone["AfricaCairo"] = "africa/cairo";
    Timezone["AfricaCasablanca"] = "africa/casablanca";
    Timezone["AfricaCeuta"] = "africa/ceuta";
    Timezone["AfricaConakry"] = "africa/conakry";
    Timezone["AfricaDakar"] = "africa/dakar";
    Timezone["AfricaDarEsSalaam"] = "africa/dar_es_salaam";
    Timezone["AfricaDjibouti"] = "africa/djibouti";
    Timezone["AfricaDouala"] = "africa/douala";
    Timezone["AfricaElAaiun"] = "africa/el_aaiun";
    Timezone["AfricaFreetown"] = "africa/freetown";
    Timezone["AfricaGaborone"] = "africa/gaborone";
    Timezone["AfricaHarare"] = "africa/harare";
    Timezone["AfricaJohannesburg"] = "africa/johannesburg";
    Timezone["AfricaJuba"] = "africa/juba";
    Timezone["AfricaKampala"] = "africa/kampala";
    Timezone["AfricaKhartoum"] = "africa/khartoum";
    Timezone["AfricaKigali"] = "africa/kigali";
    Timezone["AfricaKinshasa"] = "africa/kinshasa";
    Timezone["AfricaLagos"] = "africa/lagos";
    Timezone["AfricaLibreville"] = "africa/libreville";
    Timezone["AfricaLome"] = "africa/lome";
    Timezone["AfricaLuanda"] = "africa/luanda";
    Timezone["AfricaLubumbashi"] = "africa/lubumbashi";
    Timezone["AfricaLusaka"] = "africa/lusaka";
    Timezone["AfricaMalabo"] = "africa/malabo";
    Timezone["AfricaMaputo"] = "africa/maputo";
    Timezone["AfricaMaseru"] = "africa/maseru";
    Timezone["AfricaMbabane"] = "africa/mbabane";
    Timezone["AfricaMogadishu"] = "africa/mogadishu";
    Timezone["AfricaMonrovia"] = "africa/monrovia";
    Timezone["AfricaNairobi"] = "africa/nairobi";
    Timezone["AfricaNdjamena"] = "africa/ndjamena";
    Timezone["AfricaNiamey"] = "africa/niamey";
    Timezone["AfricaNouakchott"] = "africa/nouakchott";
    Timezone["AfricaOuagadougou"] = "africa/ouagadougou";
    Timezone["AfricaPortoNovo"] = "africa/porto-novo";
    Timezone["AfricaSaoTome"] = "africa/sao_tome";
    Timezone["AfricaTripoli"] = "africa/tripoli";
    Timezone["AfricaTunis"] = "africa/tunis";
    Timezone["AfricaWindhoek"] = "africa/windhoek";
    Timezone["AmericaAdak"] = "america/adak";
    Timezone["AmericaAnchorage"] = "america/anchorage";
    Timezone["AmericaAnguilla"] = "america/anguilla";
    Timezone["AmericaAntigua"] = "america/antigua";
    Timezone["AmericaAraguaina"] = "america/araguaina";
    Timezone["AmericaArgentinaBuenosAires"] = "america/argentina/buenos_aires";
    Timezone["AmericaArgentinaCatamarca"] = "america/argentina/catamarca";
    Timezone["AmericaArgentinaCordoba"] = "america/argentina/cordoba";
    Timezone["AmericaArgentinaJujuy"] = "america/argentina/jujuy";
    Timezone["AmericaArgentinaLaRioja"] = "america/argentina/la_rioja";
    Timezone["AmericaArgentinaMendoza"] = "america/argentina/mendoza";
    Timezone["AmericaArgentinaRioGallegos"] = "america/argentina/rio_gallegos";
    Timezone["AmericaArgentinaSalta"] = "america/argentina/salta";
    Timezone["AmericaArgentinaSanJuan"] = "america/argentina/san_juan";
    Timezone["AmericaArgentinaSanLuis"] = "america/argentina/san_luis";
    Timezone["AmericaArgentinaTucuman"] = "america/argentina/tucuman";
    Timezone["AmericaArgentinaUshuaia"] = "america/argentina/ushuaia";
    Timezone["AmericaAruba"] = "america/aruba";
    Timezone["AmericaAsuncion"] = "america/asuncion";
    Timezone["AmericaAtikokan"] = "america/atikokan";
    Timezone["AmericaBahia"] = "america/bahia";
    Timezone["AmericaBahiaBanderas"] = "america/bahia_banderas";
    Timezone["AmericaBarbados"] = "america/barbados";
    Timezone["AmericaBelem"] = "america/belem";
    Timezone["AmericaBelize"] = "america/belize";
    Timezone["AmericaBlancSablon"] = "america/blanc-sablon";
    Timezone["AmericaBoaVista"] = "america/boa_vista";
    Timezone["AmericaBogota"] = "america/bogota";
    Timezone["AmericaBoise"] = "america/boise";
    Timezone["AmericaCambridgeBay"] = "america/cambridge_bay";
    Timezone["AmericaCampoGrande"] = "america/campo_grande";
    Timezone["AmericaCancun"] = "america/cancun";
    Timezone["AmericaCaracas"] = "america/caracas";
    Timezone["AmericaCayenne"] = "america/cayenne";
    Timezone["AmericaCayman"] = "america/cayman";
    Timezone["AmericaChicago"] = "america/chicago";
    Timezone["AmericaChihuahua"] = "america/chihuahua";
    Timezone["AmericaCiudadJuarez"] = "america/ciudad_juarez";
    Timezone["AmericaCostaRica"] = "america/costa_rica";
    Timezone["AmericaCoyhaique"] = "america/coyhaique";
    Timezone["AmericaCreston"] = "america/creston";
    Timezone["AmericaCuiaba"] = "america/cuiaba";
    Timezone["AmericaCuracao"] = "america/curacao";
    Timezone["AmericaDanmarkshavn"] = "america/danmarkshavn";
    Timezone["AmericaDawson"] = "america/dawson";
    Timezone["AmericaDawsonCreek"] = "america/dawson_creek";
    Timezone["AmericaDenver"] = "america/denver";
    Timezone["AmericaDetroit"] = "america/detroit";
    Timezone["AmericaDominica"] = "america/dominica";
    Timezone["AmericaEdmonton"] = "america/edmonton";
    Timezone["AmericaEirunepe"] = "america/eirunepe";
    Timezone["AmericaElSalvador"] = "america/el_salvador";
    Timezone["AmericaFortNelson"] = "america/fort_nelson";
    Timezone["AmericaFortaleza"] = "america/fortaleza";
    Timezone["AmericaGlaceBay"] = "america/glace_bay";
    Timezone["AmericaGooseBay"] = "america/goose_bay";
    Timezone["AmericaGrandTurk"] = "america/grand_turk";
    Timezone["AmericaGrenada"] = "america/grenada";
    Timezone["AmericaGuadeloupe"] = "america/guadeloupe";
    Timezone["AmericaGuatemala"] = "america/guatemala";
    Timezone["AmericaGuayaquil"] = "america/guayaquil";
    Timezone["AmericaGuyana"] = "america/guyana";
    Timezone["AmericaHalifax"] = "america/halifax";
    Timezone["AmericaHavana"] = "america/havana";
    Timezone["AmericaHermosillo"] = "america/hermosillo";
    Timezone["AmericaIndianaIndianapolis"] = "america/indiana/indianapolis";
    Timezone["AmericaIndianaKnox"] = "america/indiana/knox";
    Timezone["AmericaIndianaMarengo"] = "america/indiana/marengo";
    Timezone["AmericaIndianaPetersburg"] = "america/indiana/petersburg";
    Timezone["AmericaIndianaTellCity"] = "america/indiana/tell_city";
    Timezone["AmericaIndianaVevay"] = "america/indiana/vevay";
    Timezone["AmericaIndianaVincennes"] = "america/indiana/vincennes";
    Timezone["AmericaIndianaWinamac"] = "america/indiana/winamac";
    Timezone["AmericaInuvik"] = "america/inuvik";
    Timezone["AmericaIqaluit"] = "america/iqaluit";
    Timezone["AmericaJamaica"] = "america/jamaica";
    Timezone["AmericaJuneau"] = "america/juneau";
    Timezone["AmericaKentuckyLouisville"] = "america/kentucky/louisville";
    Timezone["AmericaKentuckyMonticello"] = "america/kentucky/monticello";
    Timezone["AmericaKralendijk"] = "america/kralendijk";
    Timezone["AmericaLaPaz"] = "america/la_paz";
    Timezone["AmericaLima"] = "america/lima";
    Timezone["AmericaLosAngeles"] = "america/los_angeles";
    Timezone["AmericaLowerPrinces"] = "america/lower_princes";
    Timezone["AmericaMaceio"] = "america/maceio";
    Timezone["AmericaManagua"] = "america/managua";
    Timezone["AmericaManaus"] = "america/manaus";
    Timezone["AmericaMarigot"] = "america/marigot";
    Timezone["AmericaMartinique"] = "america/martinique";
    Timezone["AmericaMatamoros"] = "america/matamoros";
    Timezone["AmericaMazatlan"] = "america/mazatlan";
    Timezone["AmericaMenominee"] = "america/menominee";
    Timezone["AmericaMerida"] = "america/merida";
    Timezone["AmericaMetlakatla"] = "america/metlakatla";
    Timezone["AmericaMexicoCity"] = "america/mexico_city";
    Timezone["AmericaMiquelon"] = "america/miquelon";
    Timezone["AmericaMoncton"] = "america/moncton";
    Timezone["AmericaMonterrey"] = "america/monterrey";
    Timezone["AmericaMontevideo"] = "america/montevideo";
    Timezone["AmericaMontserrat"] = "america/montserrat";
    Timezone["AmericaNassau"] = "america/nassau";
    Timezone["AmericaNewYork"] = "america/new_york";
    Timezone["AmericaNome"] = "america/nome";
    Timezone["AmericaNoronha"] = "america/noronha";
    Timezone["AmericaNorthDakotaBeulah"] = "america/north_dakota/beulah";
    Timezone["AmericaNorthDakotaCenter"] = "america/north_dakota/center";
    Timezone["AmericaNorthDakotaNewSalem"] = "america/north_dakota/new_salem";
    Timezone["AmericaNuuk"] = "america/nuuk";
    Timezone["AmericaOjinaga"] = "america/ojinaga";
    Timezone["AmericaPanama"] = "america/panama";
    Timezone["AmericaParamaribo"] = "america/paramaribo";
    Timezone["AmericaPhoenix"] = "america/phoenix";
    Timezone["AmericaPortAuPrince"] = "america/port-au-prince";
    Timezone["AmericaPortOfSpain"] = "america/port_of_spain";
    Timezone["AmericaPortoVelho"] = "america/porto_velho";
    Timezone["AmericaPuertoRico"] = "america/puerto_rico";
    Timezone["AmericaPuntaArenas"] = "america/punta_arenas";
    Timezone["AmericaRankinInlet"] = "america/rankin_inlet";
    Timezone["AmericaRecife"] = "america/recife";
    Timezone["AmericaRegina"] = "america/regina";
    Timezone["AmericaResolute"] = "america/resolute";
    Timezone["AmericaRioBranco"] = "america/rio_branco";
    Timezone["AmericaSantarem"] = "america/santarem";
    Timezone["AmericaSantiago"] = "america/santiago";
    Timezone["AmericaSantoDomingo"] = "america/santo_domingo";
    Timezone["AmericaSaoPaulo"] = "america/sao_paulo";
    Timezone["AmericaScoresbysund"] = "america/scoresbysund";
    Timezone["AmericaSitka"] = "america/sitka";
    Timezone["AmericaStBarthelemy"] = "america/st_barthelemy";
    Timezone["AmericaStJohns"] = "america/st_johns";
    Timezone["AmericaStKitts"] = "america/st_kitts";
    Timezone["AmericaStLucia"] = "america/st_lucia";
    Timezone["AmericaStThomas"] = "america/st_thomas";
    Timezone["AmericaStVincent"] = "america/st_vincent";
    Timezone["AmericaSwiftCurrent"] = "america/swift_current";
    Timezone["AmericaTegucigalpa"] = "america/tegucigalpa";
    Timezone["AmericaThule"] = "america/thule";
    Timezone["AmericaTijuana"] = "america/tijuana";
    Timezone["AmericaToronto"] = "america/toronto";
    Timezone["AmericaTortola"] = "america/tortola";
    Timezone["AmericaVancouver"] = "america/vancouver";
    Timezone["AmericaWhitehorse"] = "america/whitehorse";
    Timezone["AmericaWinnipeg"] = "america/winnipeg";
    Timezone["AmericaYakutat"] = "america/yakutat";
    Timezone["AntarcticaCasey"] = "antarctica/casey";
    Timezone["AntarcticaDavis"] = "antarctica/davis";
    Timezone["AntarcticaDumontdurville"] = "antarctica/dumontdurville";
    Timezone["AntarcticaMacquarie"] = "antarctica/macquarie";
    Timezone["AntarcticaMawson"] = "antarctica/mawson";
    Timezone["AntarcticaMcmurdo"] = "antarctica/mcmurdo";
    Timezone["AntarcticaPalmer"] = "antarctica/palmer";
    Timezone["AntarcticaRothera"] = "antarctica/rothera";
    Timezone["AntarcticaSyowa"] = "antarctica/syowa";
    Timezone["AntarcticaTroll"] = "antarctica/troll";
    Timezone["AntarcticaVostok"] = "antarctica/vostok";
    Timezone["ArcticLongyearbyen"] = "arctic/longyearbyen";
    Timezone["AsiaAden"] = "asia/aden";
    Timezone["AsiaAlmaty"] = "asia/almaty";
    Timezone["AsiaAmman"] = "asia/amman";
    Timezone["AsiaAnadyr"] = "asia/anadyr";
    Timezone["AsiaAqtau"] = "asia/aqtau";
    Timezone["AsiaAqtobe"] = "asia/aqtobe";
    Timezone["AsiaAshgabat"] = "asia/ashgabat";
    Timezone["AsiaAtyrau"] = "asia/atyrau";
    Timezone["AsiaBaghdad"] = "asia/baghdad";
    Timezone["AsiaBahrain"] = "asia/bahrain";
    Timezone["AsiaBaku"] = "asia/baku";
    Timezone["AsiaBangkok"] = "asia/bangkok";
    Timezone["AsiaBarnaul"] = "asia/barnaul";
    Timezone["AsiaBeirut"] = "asia/beirut";
    Timezone["AsiaBishkek"] = "asia/bishkek";
    Timezone["AsiaBrunei"] = "asia/brunei";
    Timezone["AsiaChita"] = "asia/chita";
    Timezone["AsiaColombo"] = "asia/colombo";
    Timezone["AsiaDamascus"] = "asia/damascus";
    Timezone["AsiaDhaka"] = "asia/dhaka";
    Timezone["AsiaDili"] = "asia/dili";
    Timezone["AsiaDubai"] = "asia/dubai";
    Timezone["AsiaDushanbe"] = "asia/dushanbe";
    Timezone["AsiaFamagusta"] = "asia/famagusta";
    Timezone["AsiaGaza"] = "asia/gaza";
    Timezone["AsiaHebron"] = "asia/hebron";
    Timezone["AsiaHoChiMinh"] = "asia/ho_chi_minh";
    Timezone["AsiaHongKong"] = "asia/hong_kong";
    Timezone["AsiaHovd"] = "asia/hovd";
    Timezone["AsiaIrkutsk"] = "asia/irkutsk";
    Timezone["AsiaJakarta"] = "asia/jakarta";
    Timezone["AsiaJayapura"] = "asia/jayapura";
    Timezone["AsiaJerusalem"] = "asia/jerusalem";
    Timezone["AsiaKabul"] = "asia/kabul";
    Timezone["AsiaKamchatka"] = "asia/kamchatka";
    Timezone["AsiaKarachi"] = "asia/karachi";
    Timezone["AsiaKathmandu"] = "asia/kathmandu";
    Timezone["AsiaKhandyga"] = "asia/khandyga";
    Timezone["AsiaKolkata"] = "asia/kolkata";
    Timezone["AsiaKrasnoyarsk"] = "asia/krasnoyarsk";
    Timezone["AsiaKualaLumpur"] = "asia/kuala_lumpur";
    Timezone["AsiaKuching"] = "asia/kuching";
    Timezone["AsiaKuwait"] = "asia/kuwait";
    Timezone["AsiaMacau"] = "asia/macau";
    Timezone["AsiaMagadan"] = "asia/magadan";
    Timezone["AsiaMakassar"] = "asia/makassar";
    Timezone["AsiaManila"] = "asia/manila";
    Timezone["AsiaMuscat"] = "asia/muscat";
    Timezone["AsiaNicosia"] = "asia/nicosia";
    Timezone["AsiaNovokuznetsk"] = "asia/novokuznetsk";
    Timezone["AsiaNovosibirsk"] = "asia/novosibirsk";
    Timezone["AsiaOmsk"] = "asia/omsk";
    Timezone["AsiaOral"] = "asia/oral";
    Timezone["AsiaPhnomPenh"] = "asia/phnom_penh";
    Timezone["AsiaPontianak"] = "asia/pontianak";
    Timezone["AsiaPyongyang"] = "asia/pyongyang";
    Timezone["AsiaQatar"] = "asia/qatar";
    Timezone["AsiaQostanay"] = "asia/qostanay";
    Timezone["AsiaQyzylorda"] = "asia/qyzylorda";
    Timezone["AsiaRiyadh"] = "asia/riyadh";
    Timezone["AsiaSakhalin"] = "asia/sakhalin";
    Timezone["AsiaSamarkand"] = "asia/samarkand";
    Timezone["AsiaSeoul"] = "asia/seoul";
    Timezone["AsiaShanghai"] = "asia/shanghai";
    Timezone["AsiaSingapore"] = "asia/singapore";
    Timezone["AsiaSrednekolymsk"] = "asia/srednekolymsk";
    Timezone["AsiaTaipei"] = "asia/taipei";
    Timezone["AsiaTashkent"] = "asia/tashkent";
    Timezone["AsiaTbilisi"] = "asia/tbilisi";
    Timezone["AsiaTehran"] = "asia/tehran";
    Timezone["AsiaThimphu"] = "asia/thimphu";
    Timezone["AsiaTokyo"] = "asia/tokyo";
    Timezone["AsiaTomsk"] = "asia/tomsk";
    Timezone["AsiaUlaanbaatar"] = "asia/ulaanbaatar";
    Timezone["AsiaUrumqi"] = "asia/urumqi";
    Timezone["AsiaUstNera"] = "asia/ust-nera";
    Timezone["AsiaVientiane"] = "asia/vientiane";
    Timezone["AsiaVladivostok"] = "asia/vladivostok";
    Timezone["AsiaYakutsk"] = "asia/yakutsk";
    Timezone["AsiaYangon"] = "asia/yangon";
    Timezone["AsiaYekaterinburg"] = "asia/yekaterinburg";
    Timezone["AsiaYerevan"] = "asia/yerevan";
    Timezone["AtlanticAzores"] = "atlantic/azores";
    Timezone["AtlanticBermuda"] = "atlantic/bermuda";
    Timezone["AtlanticCanary"] = "atlantic/canary";
    Timezone["AtlanticCapeVerde"] = "atlantic/cape_verde";
    Timezone["AtlanticFaroe"] = "atlantic/faroe";
    Timezone["AtlanticMadeira"] = "atlantic/madeira";
    Timezone["AtlanticReykjavik"] = "atlantic/reykjavik";
    Timezone["AtlanticSouthGeorgia"] = "atlantic/south_georgia";
    Timezone["AtlanticStHelena"] = "atlantic/st_helena";
    Timezone["AtlanticStanley"] = "atlantic/stanley";
    Timezone["AustraliaAdelaide"] = "australia/adelaide";
    Timezone["AustraliaBrisbane"] = "australia/brisbane";
    Timezone["AustraliaBrokenHill"] = "australia/broken_hill";
    Timezone["AustraliaDarwin"] = "australia/darwin";
    Timezone["AustraliaEucla"] = "australia/eucla";
    Timezone["AustraliaHobart"] = "australia/hobart";
    Timezone["AustraliaLindeman"] = "australia/lindeman";
    Timezone["AustraliaLordHowe"] = "australia/lord_howe";
    Timezone["AustraliaMelbourne"] = "australia/melbourne";
    Timezone["AustraliaPerth"] = "australia/perth";
    Timezone["AustraliaSydney"] = "australia/sydney";
    Timezone["EuropeAmsterdam"] = "europe/amsterdam";
    Timezone["EuropeAndorra"] = "europe/andorra";
    Timezone["EuropeAstrakhan"] = "europe/astrakhan";
    Timezone["EuropeAthens"] = "europe/athens";
    Timezone["EuropeBelgrade"] = "europe/belgrade";
    Timezone["EuropeBerlin"] = "europe/berlin";
    Timezone["EuropeBratislava"] = "europe/bratislava";
    Timezone["EuropeBrussels"] = "europe/brussels";
    Timezone["EuropeBucharest"] = "europe/bucharest";
    Timezone["EuropeBudapest"] = "europe/budapest";
    Timezone["EuropeBusingen"] = "europe/busingen";
    Timezone["EuropeChisinau"] = "europe/chisinau";
    Timezone["EuropeCopenhagen"] = "europe/copenhagen";
    Timezone["EuropeDublin"] = "europe/dublin";
    Timezone["EuropeGibraltar"] = "europe/gibraltar";
    Timezone["EuropeGuernsey"] = "europe/guernsey";
    Timezone["EuropeHelsinki"] = "europe/helsinki";
    Timezone["EuropeIsleOfMan"] = "europe/isle_of_man";
    Timezone["EuropeIstanbul"] = "europe/istanbul";
    Timezone["EuropeJersey"] = "europe/jersey";
    Timezone["EuropeKaliningrad"] = "europe/kaliningrad";
    Timezone["EuropeKirov"] = "europe/kirov";
    Timezone["EuropeKyiv"] = "europe/kyiv";
    Timezone["EuropeLisbon"] = "europe/lisbon";
    Timezone["EuropeLjubljana"] = "europe/ljubljana";
    Timezone["EuropeLondon"] = "europe/london";
    Timezone["EuropeLuxembourg"] = "europe/luxembourg";
    Timezone["EuropeMadrid"] = "europe/madrid";
    Timezone["EuropeMalta"] = "europe/malta";
    Timezone["EuropeMariehamn"] = "europe/mariehamn";
    Timezone["EuropeMinsk"] = "europe/minsk";
    Timezone["EuropeMonaco"] = "europe/monaco";
    Timezone["EuropeMoscow"] = "europe/moscow";
    Timezone["EuropeOslo"] = "europe/oslo";
    Timezone["EuropeParis"] = "europe/paris";
    Timezone["EuropePodgorica"] = "europe/podgorica";
    Timezone["EuropePrague"] = "europe/prague";
    Timezone["EuropeRiga"] = "europe/riga";
    Timezone["EuropeRome"] = "europe/rome";
    Timezone["EuropeSamara"] = "europe/samara";
    Timezone["EuropeSanMarino"] = "europe/san_marino";
    Timezone["EuropeSarajevo"] = "europe/sarajevo";
    Timezone["EuropeSaratov"] = "europe/saratov";
    Timezone["EuropeSimferopol"] = "europe/simferopol";
    Timezone["EuropeSkopje"] = "europe/skopje";
    Timezone["EuropeSofia"] = "europe/sofia";
    Timezone["EuropeStockholm"] = "europe/stockholm";
    Timezone["EuropeTallinn"] = "europe/tallinn";
    Timezone["EuropeTirane"] = "europe/tirane";
    Timezone["EuropeUlyanovsk"] = "europe/ulyanovsk";
    Timezone["EuropeVaduz"] = "europe/vaduz";
    Timezone["EuropeVatican"] = "europe/vatican";
    Timezone["EuropeVienna"] = "europe/vienna";
    Timezone["EuropeVilnius"] = "europe/vilnius";
    Timezone["EuropeVolgograd"] = "europe/volgograd";
    Timezone["EuropeWarsaw"] = "europe/warsaw";
    Timezone["EuropeZagreb"] = "europe/zagreb";
    Timezone["EuropeZurich"] = "europe/zurich";
    Timezone["IndianAntananarivo"] = "indian/antananarivo";
    Timezone["IndianChagos"] = "indian/chagos";
    Timezone["IndianChristmas"] = "indian/christmas";
    Timezone["IndianCocos"] = "indian/cocos";
    Timezone["IndianComoro"] = "indian/comoro";
    Timezone["IndianKerguelen"] = "indian/kerguelen";
    Timezone["IndianMahe"] = "indian/mahe";
    Timezone["IndianMaldives"] = "indian/maldives";
    Timezone["IndianMauritius"] = "indian/mauritius";
    Timezone["IndianMayotte"] = "indian/mayotte";
    Timezone["IndianReunion"] = "indian/reunion";
    Timezone["PacificApia"] = "pacific/apia";
    Timezone["PacificAuckland"] = "pacific/auckland";
    Timezone["PacificBougainville"] = "pacific/bougainville";
    Timezone["PacificChatham"] = "pacific/chatham";
    Timezone["PacificChuuk"] = "pacific/chuuk";
    Timezone["PacificEaster"] = "pacific/easter";
    Timezone["PacificEfate"] = "pacific/efate";
    Timezone["PacificFakaofo"] = "pacific/fakaofo";
    Timezone["PacificFiji"] = "pacific/fiji";
    Timezone["PacificFunafuti"] = "pacific/funafuti";
    Timezone["PacificGalapagos"] = "pacific/galapagos";
    Timezone["PacificGambier"] = "pacific/gambier";
    Timezone["PacificGuadalcanal"] = "pacific/guadalcanal";
    Timezone["PacificGuam"] = "pacific/guam";
    Timezone["PacificHonolulu"] = "pacific/honolulu";
    Timezone["PacificKanton"] = "pacific/kanton";
    Timezone["PacificKiritimati"] = "pacific/kiritimati";
    Timezone["PacificKosrae"] = "pacific/kosrae";
    Timezone["PacificKwajalein"] = "pacific/kwajalein";
    Timezone["PacificMajuro"] = "pacific/majuro";
    Timezone["PacificMarquesas"] = "pacific/marquesas";
    Timezone["PacificMidway"] = "pacific/midway";
    Timezone["PacificNauru"] = "pacific/nauru";
    Timezone["PacificNiue"] = "pacific/niue";
    Timezone["PacificNorfolk"] = "pacific/norfolk";
    Timezone["PacificNoumea"] = "pacific/noumea";
    Timezone["PacificPagoPago"] = "pacific/pago_pago";
    Timezone["PacificPalau"] = "pacific/palau";
    Timezone["PacificPitcairn"] = "pacific/pitcairn";
    Timezone["PacificPohnpei"] = "pacific/pohnpei";
    Timezone["PacificPortMoresby"] = "pacific/port_moresby";
    Timezone["PacificRarotonga"] = "pacific/rarotonga";
    Timezone["PacificSaipan"] = "pacific/saipan";
    Timezone["PacificTahiti"] = "pacific/tahiti";
    Timezone["PacificTarawa"] = "pacific/tarawa";
    Timezone["PacificTongatapu"] = "pacific/tongatapu";
    Timezone["PacificWake"] = "pacific/wake";
    Timezone["PacificWallis"] = "pacific/wallis";
    Timezone["Utc"] = "utc";
})(Timezone || (Timezone = {}));

var Output;
(function (Output) {
    Output["Jpg"] = "jpg";
    Output["Jpeg"] = "jpeg";
    Output["Png"] = "png";
    Output["Webp"] = "webp";
    Output["Heic"] = "heic";
    Output["Avif"] = "avif";
    Output["Gif"] = "gif";
})(Output || (Output = {}));

var ExecutionMethod;
(function (ExecutionMethod) {
    ExecutionMethod["GET"] = "GET";
    ExecutionMethod["POST"] = "POST";
    ExecutionMethod["PUT"] = "PUT";
    ExecutionMethod["PATCH"] = "PATCH";
    ExecutionMethod["DELETE"] = "DELETE";
    ExecutionMethod["OPTIONS"] = "OPTIONS";
    ExecutionMethod["HEAD"] = "HEAD";
})(ExecutionMethod || (ExecutionMethod = {}));

var ImageGravity;
(function (ImageGravity) {
    ImageGravity["Center"] = "center";
    ImageGravity["TopLeft"] = "top-left";
    ImageGravity["Top"] = "top";
    ImageGravity["TopRight"] = "top-right";
    ImageGravity["Left"] = "left";
    ImageGravity["Right"] = "right";
    ImageGravity["BottomLeft"] = "bottom-left";
    ImageGravity["Bottom"] = "bottom";
    ImageGravity["BottomRight"] = "bottom-right";
})(ImageGravity || (ImageGravity = {}));

var ImageFormat;
(function (ImageFormat) {
    ImageFormat["Jpg"] = "jpg";
    ImageFormat["Jpeg"] = "jpeg";
    ImageFormat["Png"] = "png";
    ImageFormat["Webp"] = "webp";
    ImageFormat["Heic"] = "heic";
    ImageFormat["Avif"] = "avif";
    ImageFormat["Gif"] = "gif";
})(ImageFormat || (ImageFormat = {}));

var ExecutionTrigger;
(function (ExecutionTrigger) {
    ExecutionTrigger["Http"] = "http";
    ExecutionTrigger["Schedule"] = "schedule";
    ExecutionTrigger["Event"] = "event";
})(ExecutionTrigger || (ExecutionTrigger = {}));

var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus["Waiting"] = "waiting";
    ExecutionStatus["Processing"] = "processing";
    ExecutionStatus["Completed"] = "completed";
    ExecutionStatus["Failed"] = "failed";
    ExecutionStatus["Scheduled"] = "scheduled";
})(ExecutionStatus || (ExecutionStatus = {}));

export { Account, AppwriteException, AuthenticationFactor, AuthenticatorType, Avatars, Browser, Client, Condition, CreditCard, Databases, ExecutionMethod, ExecutionStatus, ExecutionTrigger, Flag, Functions, Graphql, ID, ImageFormat, ImageGravity, Locale, Messaging, OAuthProvider, Operator, Output, Permission, Query, Role, Storage, TablesDB, Teams, Theme, Timezone };
//# sourceMappingURL=sdk.js.map
